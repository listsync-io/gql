import re

from os.path import join as basename
from typing import Optional, Dict, Any
from graphql import GraphQLSchema
from gql.config import Config
from gql.utils_codegen import CodeChunk
from gql.query_parser import (
    ParsedQuery,
    ParsedField,
    ParsedObject,
    ParsedOperation,
)
import textwrap
from typing import List


def dedent(text):
    return re.sub(r"\s+", " ", text).strip()


class DataclassesRenderer:
    def __init__(self, schema: GraphQLSchema, config: Config):
        self.schema = schema
        self.config = config

    def render_shared_code(self):
        buffer = CodeChunk()

        buffer.write(
            textwrap.dedent(
                """
                    # AUTOGENERATED file. Do not Change!
                    import re
                    from functools import partial
                    from typing import Any, Callable, Mapping, List, Optional, Dict
                    from dataclasses import dataclass, field
                    from dataclasses_json import dataclass_json, config
                    from dateutil import parser
                    from datetime import datetime
                    from marshmallow import fields as marshmallow_fields
                    from app.klasses import Executor, ModelHelper
                    
                    def datetime_encoder(dt: datetime) -> str:
                        return dt.isoformat() if dt else None

                    def datetime_decoder(dt_str: str) -> Optional[datetime]:
                        return parser.parse(dt_str) if dt_str else None
            """
            )
        )

        return str(buffer)

    def render(self, parsed_query: ParsedQuery, full_path: str):
        buffer = CodeChunk()

        sorted_objects = sorted(
            parsed_query.objects,
            key=lambda obj: 1 if isinstance(obj, ParsedOperation) else 0,
        )

        for obj in sorted_objects:
            if isinstance(obj, ParsedObject):
                output = self.render_object(obj)
            elif isinstance(obj, ParsedOperation):
                parsed_op = self.ensure_unique_names_and_types(obj)

                output = self.render_operation(
                    operation_variables=parsed_op.variables,
                    children_ops=parsed_op.children,
                    query_name=parsed_op.name,
                    query_string=dedent(parsed_query.query),
                )

            buffer.write(output)

        return str(buffer)

    def render_object(self, obj: ParsedObject):
        buffer = CodeChunk()

        buffer.write("@dataclass_json")
        buffer.write("@dataclass")

        # render fields
        sorted_fields = sorted(
            obj.fields,
            key=lambda f: (f.type == "DateTime", f.nullable),
        )

        with buffer.write_block(f"class {obj.name}:"):
            for field in sorted_fields:
                buffer.write(self.render_field(field))

        # render child objects
        for child_object in obj.children:
            buffer.write(self.render_object(child_object))

        # pass if not children or fields
        if not (obj.children or obj.fields):
            buffer.write("pass")

        return str(buffer)

    def render_operation(
        self,
        operation_variables: ParsedOperation,
        children_ops: Optional[List[ParsedOperation]],
        query_name: str,
        query_string: str,
    ):
        buffer = CodeChunk()

        class_name = query_name

        buffer.write("@dataclass_json")
        buffer.write("@dataclass")
        with buffer.write_block(f"class {class_name}(Executor):"):
            buffer.write(f"__NAME__ = '{query_name}'")
            buffer.write(f"__QUERY__ = '{dedent(query_string)}'")

            # Execution functions
            vars_args_list = [f"{var.name}=None" for var in operation_variables]
            vars_args_str = ", ".join(vars_args_list)
            if vars_args_str:
                vars_args_str += ", "

            variables_dict_lines = []
            for x in operation_variables:
                variables_dict_lines.append(f"'{x.name}'")

            variables_dict_str = ", ".join(variables_dict_lines)
            buffer.write(f"__PARAMS__ = [{variables_dict_str}]")

            # query_name = parsed_query.objects[0].name

            anan = query_name.replace("find", "").replace("get", "")
            singular_str = anan[:-1] if anan.endswith("s") else anan
            snake_case_str = re.sub(r"(?<!^)(?=[A-Z])", "_", singular_str).lower()

            buffer.write(f"__KEY__ = '{snake_case_str}'")

        with buffer.write_block(""):
            buffer.write(f"data: {query_name}Data = None")
            buffer.write("errors: Any = None")

        # Render children
        for child_object in children_ops:
            buffer.write(self.render_object(child_object))

        return str(buffer)

    @staticmethod
    def render_field(field: ParsedField):
        suffix = ""
        field_type = field.type

        if field_type == "json":
            field_type = "Dict"

        is_optional = False
        # something fucked up - cemre
        if field.nullable:
            # bu böyle olmalı yoksa parse etmiyor dict gibi kullanılıyor.
            if field.name == "organization":
                suffix = ""
            else:
                is_optional = True
                suffix = f"= {field.default_value}"

        if field_type == "DateTime":
            is_optional = True
            suffix = """= field(
                default=None,
                metadata=config(
                    encoder=datetime_encoder,
                    decoder=datetime_decoder,
                    mm_field=marshmallow_fields.DateTime(format="iso"),
                ),
            )"""
            field_type = "datetime"

        if field_type == "numeric":
            field_type = "float"

        if is_optional:
            field_type = f"Optional[{field_type}]"

        return f"{field.name}: {field_type} {suffix}"

    def ensure_unique_names_and_types(self, operation):
        name_count = {}
        type_count = {}

        def unique_name(name, count_dict):
            if "_response" not in name:
                return name

            if name in count_dict:
                count_dict[name] += 1
                return f"{name}_{count_dict[name]}"
            else:
                count_dict[name] = 0
                return name

        def process_object(parsed_object):
            # Ensure the name of the ParsedObject is unique
            parsed_object.name = unique_name(parsed_object.name, name_count)

            # Process each field to ensure the type is unique
            for field in parsed_object.fields:
                field.type = unique_name(field.type, type_count)

            # Recursively process any children objects
            for child in parsed_object.children:
                process_object(child)

        # Start processing from the root object
        for child in operation.children:
            process_object(child)

        return operation
